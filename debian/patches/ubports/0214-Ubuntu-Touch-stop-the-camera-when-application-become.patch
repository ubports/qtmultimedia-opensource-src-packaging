Description: Ubuntu Touch: stop the camera when application becomes inactive
 Ubuntu Touch will stop the application with SIGSTOP when switching the
 application to background. To make sure camera is in sane state, and to
 allow another app getting to foreground to use the camera, the CameraBin
 Control will listen to the application state and unload the camera when
 the application becomes inactive.
 .
 CameraBinRecorder will also listen to the state of the application and
 stop the recording if the application become inactive. This ensure that
 we'll be able to unload the camera. When the application becomes active
 again, the recording won't be restarted to prevent confusion.
 .
 This patch is Ubuntu Touch specific, thus it shouldn't be forwarded to
 the upstream. However, other distributions are welcome to incorporate
 this patch.
Author: Ratchanan Srirattanamet <ratchanan@ubports.com>
Forwarded: not-needed
Last-Update: 2019-10-11
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/src/plugins/gstreamer/camerabin/camerabincontrol.cpp
+++ b/src/plugins/gstreamer/camerabin/camerabincontrol.cpp
@@ -48,6 +48,7 @@
 #include <QtCore/qdebug.h>
 #include <QtCore/qfile.h>
 #include <QtCore/qmetaobject.h>
+#include <QtGui/qguiapplication.h>
 
 QT_BEGIN_NAMESPACE
 
@@ -58,6 +59,7 @@
     :QCameraControl(session),
     m_session(session),
     m_state(QCamera::UnloadedState),
+    m_savedState(-1),
     m_reloadPending(false)
 {
     connect(m_session, SIGNAL(statusChanged(QCamera::Status)),
@@ -80,6 +82,11 @@
 
     connect(m_session, SIGNAL(busyChanged(bool)),
             SLOT(handleBusyChanged(bool)));
+
+    if (qApp) {
+        connect(qApp, SIGNAL(applicationStateChanged(Qt::ApplicationState)),
+                this, SLOT(handleApplicationStateChanged(Qt::ApplicationState)));
+    }
 }
 
 CameraBinControl::~CameraBinControl()
@@ -113,9 +120,29 @@
 
 void CameraBinControl::setState(QCamera::State state)
 {
+    // If the application is inactive, the camera shouldn't be started. Save the desired state
+    // instead and it will be set when the application becomes active.
+    if (qApp && qApp->applicationState() != Qt::ApplicationActive) {
+#ifdef CAMEABIN_DEBUG
+        qDebug() << Q_FUNC_INFO << "Application is not active, state change to"
+                 << ENUM_NAME(QCamera, "State", state) << "is delayed."
+#endif
+        m_savedState = state;
+        return;
+    }
+
+    doSetState(state);
+}
+
+// doSetState is required to allow handleApplicationStateChanged() to circumvent
+// application state check.
+
+void CameraBinControl::doSetState(QCamera::State state)
+{
 #ifdef CAMEABIN_DEBUG
     qDebug() << Q_FUNC_INFO << ENUM_NAME(QCamera, "State", state);
 #endif
+
     if (m_state != state) {
         m_state = state;
 
@@ -303,4 +330,19 @@
     g_object_set(G_OBJECT(m_session->cameraBin()), "flags", flags, NULL);
 }
 
+void CameraBinControl::handleApplicationStateChanged(Qt::ApplicationState appState) {
+    // App state can jumps from Active to Suspended. Thus we check for "not active".
+    if (appState != Qt::ApplicationActive) {
+        if (m_state != QCamera::UnloadedState) {
+            m_savedState = m_state;
+            doSetState(QCamera::UnloadedState);
+        }
+    } else {
+        if (m_savedState != -1) {
+            doSetState(QCamera::State(m_savedState));
+            m_savedState = -1;
+        }
+    }
+}
+
 QT_END_NAMESPACE
--- a/src/plugins/gstreamer/camerabin/camerabincontrol.h
+++ b/src/plugins/gstreamer/camerabin/camerabincontrol.h
@@ -86,11 +86,15 @@
     void handleBusyChanged(bool);
     void handleCameraError(int error, const QString &errorString);
 
+    void handleApplicationStateChanged(Qt::ApplicationState state);
+
 private:
     void updateSupportedResolutions(const QString &device);
+    void doSetState(QCamera::State state);
 
     CameraBinSession *m_session;
     QCamera::State m_state;
+    int m_savedState;
     CamerabinResourcePolicy *m_resourcePolicy;
 
     bool m_reloadPending;
--- a/src/plugins/gstreamer/camerabin/camerabinrecorder.cpp
+++ b/src/plugins/gstreamer/camerabin/camerabinrecorder.cpp
@@ -44,6 +44,7 @@
 #include "camerabinvideoencoder.h"
 #include "camerabincontainer.h"
 #include <QtCore/QDebug>
+#include <QtGui/qguiapplication.h>
 
 
 QT_BEGIN_NAMESPACE
@@ -53,7 +54,9 @@
      m_session(session),
      m_state(QMediaRecorder::StoppedState),
      m_status(QMediaRecorder::UnloadedStatus),
-     m_busHelper(session->bus())
+     m_busHelper(session->bus()),
+     m_awaitingAudioBuffer(false),
+     m_audioBufferProbe(this)
 {
     connect(m_session, SIGNAL(statusChanged(QCamera::Status)), SLOT(updateStatus()));
     connect(m_session, SIGNAL(pendingStateChanged(QCamera::State)), SLOT(updateStatus()));
@@ -65,6 +68,11 @@
             this, SLOT(updateStatus()));
 
     m_busHelper->installMessageFilter(this);
+
+    if (qApp) {
+        connect(qApp, SIGNAL(applicationStateChanged(Qt::ApplicationState)),
+                this, SLOT(handleApplicationStateChanged()));
+    }
 }
 
 CameraBinRecorder::~CameraBinRecorder()
@@ -253,6 +261,7 @@
         m_state = state;
         m_status = QMediaRecorder::FinalizingStatus;
         m_session->stopVideoRecording();
+        stopAwaitForAudioBuffer();
         break;
     case QMediaRecorder::PausedState:
         emit error(QMediaRecorder::ResourceError, tr("QMediaRecorder::pause() is not supported by camerabin2."));
@@ -268,6 +277,7 @@
             m_state = state;
             m_status = QMediaRecorder::RecordingStatus;
             emit actualLocationChanged(m_session->outputLocation());
+            awaitForAudioBuffer();
         }
     }
 
@@ -340,5 +350,82 @@
     return false;
 }
 
+void CameraBinRecorder::handleApplicationStateChanged() {
+    // If we're recording, stop the recording if a) the application is not
+    // active (app state can jumps from Active to Suspended) and b) we've seen
+    // at least 1 audio buffer (i.e. we're not waiting for the trust prompt).
+
+    // Later, when the app become active again, don't restart the recording
+    // as it will confuse the user.
+
+    Qt::ApplicationState appState = qApp
+                                    ? qApp->applicationState()
+                                    : Qt::ApplicationActive;
+
+    if (appState != Qt::ApplicationActive
+            && m_state != QMediaRecorder::StoppedState
+            && !(m_awaitingAudioBuffer.load()))
+        setState(QMediaRecorder::StoppedState);
+}
+
+// In order to know that an audio buffer has arrived, we have to attach a pad
+// probe to the audio element's srcpad inside the CameraBin. Unfortunately,
+// there's no clean way to do this other than looking up the element inside the
+// CameraBin itself.
+
+// Caller owns the reference of the returned pad.
+GstPad * CameraBinRecorder::findAudioSrcPad() {
+    GstBin * camera_bin = GST_BIN(m_session->cameraBin());
+    if (!camera_bin)
+        return nullptr;
+
+    GstElement * audioSrc = gst_bin_get_by_name(camera_bin, "audiosrc");
+    if (!audioSrc)
+        return nullptr;
+
+    GstPad * audioSrcPad = gst_element_get_static_pad(audioSrc, "src");
+    gst_object_unref(audioSrc);
+    return audioSrcPad;
+}
+
+void CameraBinRecorder::awaitForAudioBuffer() {
+    GstPad * audioSrcPad = findAudioSrcPad();
+    if (!audioSrcPad)
+        // Probably because audio is not recorded.
+        return;
+
+    m_awaitingAudioBuffer.store(true);
+    m_audioBufferProbe.addProbeToPad(audioSrcPad);
+    gst_object_unref(audioSrcPad);
+}
+
+// This function can be called from both the probe and the setState() function.
+void CameraBinRecorder::stopAwaitForAudioBuffer() {
+    GstPad * audioSrcPad = findAudioSrcPad();
+    if (!audioSrcPad)
+        // Probably because audio is not recorded.
+        return;
+
+    m_audioBufferProbe.removeProbeFromPad(audioSrcPad);
+    m_awaitingAudioBuffer.store(false);
+    gst_object_unref(audioSrcPad);
+}
+
+bool CameraBinRecorder::AudioBufferProbe::probeBuffer(GstBuffer * buffer) {
+    Q_UNUSED(buffer);
+    recorder->stopAwaitForAudioBuffer();
+
+    // If we receive a buffer while the app is inactive, stop the recording.
+    // The permission is granted, but the user switched away before we knew it.
+    // handleApplicationStateChanged() will re-read the app state and act
+    // accordingly.
+    // TODO: this is kind of racy. We might receive a buffer before Unity8
+    // returns focus to the app.
+    QMetaObject::invokeMethod(recorder, "handleApplicationStateChanged",
+                                Qt::QueuedConnection);
+
+    return true;
+}
+
 QT_END_NAMESPACE
 
--- a/src/plugins/gstreamer/camerabin/camerabinrecorder.h
+++ b/src/plugins/gstreamer/camerabin/camerabinrecorder.h
@@ -88,6 +88,9 @@
 
     void updateStatus();
 
+private slots:
+    void handleApplicationStateChanged();
+
 private:
     CameraBinSession *m_session;
     QMediaRecorder::State m_state;
@@ -96,6 +99,26 @@
      * we keep a weak pointer reference ourself so that we don't depend on
      * destruction order. */
     QPointer<QGstreamerBusHelper> m_busHelper;
+
+    // Might be accessed from the main thread or the probe.
+    QAtomicInteger<bool> m_awaitingAudioBuffer;
+
+    class AudioBufferProbe : public QGstreamerBufferProbe {
+    public:
+        AudioBufferProbe(CameraBinRecorder * r)
+            : QGstreamerBufferProbe(ProbeBuffers)
+            , recorder(r)
+        {}
+
+        bool probeBuffer(GstBuffer *buffer) override;
+
+    private:
+        CameraBinRecorder * recorder;
+    } m_audioBufferProbe;
+
+    GstPad * findAudioSrcPad();
+    void awaitForAudioBuffer();
+    void stopAwaitForAudioBuffer();
 };
 
 QT_END_NAMESPACE
